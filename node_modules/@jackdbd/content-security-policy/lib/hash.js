import defDebug from 'debug';
import { globby } from 'globby';
import { DEBUG_PREFIX } from './constants.js';
import { scriptTagsContents, styleTagsContents, inlineEventHandlerContents, inlineStyleContents } from './html-parsers.js';
import { contentHash, hashAlgorithmFromCspSourceValues } from './utils.js';
const debug = defDebug(`${DEBUG_PREFIX}:hash`);
/**
 * Detects the hash algorithm to use for all CSP source values in a CSP directive.
 * Different directives might use different hash algorithms.
 */
export const hashAlgorithmMap = (config) => {
    const m = {
        'script-src': undefined,
        'script-src-attr': undefined,
        'script-src-elem': undefined,
        'style-src': undefined,
        'style-src-attr': undefined,
        'style-src-elem': undefined
    };
    const errors = [];
    const directives = Object.keys(m);
    directives.forEach((directive) => {
        const sources = config[directive];
        if (sources && Array.isArray(sources) && sources.length > 0) {
            debug(`CSP directive ${directive} specifies ${sources.length} CSP source value/s: %o`, sources);
            const { value, error } = hashAlgorithmFromCspSourceValues(sources);
            if (error) {
                errors.push(error);
            }
            if (value) {
                m[directive] = value;
            }
        }
    });
    if (errors.length > 0) {
        const message = [
            `could not figure out which hash algorithms to use in Content-Security-Policy directives`,
            ...errors.map((err) => err.message)
        ].join('; ');
        throw new Error(message);
    }
    return m;
};
export var Algorithm;
(function (Algorithm) {
    Algorithm["sha256"] = "sha256";
    Algorithm["sha384"] = "sha384";
    Algorithm["sha512"] = "sha512";
})(Algorithm || (Algorithm = {}));
/**
 * @internal
 */
export const uniqueHashes = async ({ algorithm, parser, patterns }) => {
    const paths = await globby(patterns);
    debug(`Found ${paths.length} HTML ${paths.length === 1 ? 'file' : 'files'} matching these glob patterns %O`, patterns);
    const promises = paths.map(async (filepath) => {
        const contents = await parser(filepath);
        return contents.map((content) => contentHash({ algorithm, content }));
    });
    // unflattened, with duplicates
    const hashes = await Promise.all(promises);
    // flattened, without duplicates and empty hashes
    const hashesUnique = [...new Set(...hashes.filter((hash) => hash.length > 0))];
    debug(`${hashesUnique.length} ${hashesUnique.length === 1 ? `hash` : `unique hashes`} computed from inlined content (across all pages).`);
    return hashesUnique;
};
/**
 * @internal
 */
export const hashesScriptSrcAttr = async ({ algorithm, patterns }) => {
    return await uniqueHashes({
        algorithm,
        parser: inlineEventHandlerContents,
        patterns
    });
};
/**
 * @internal
 */
export const hashesScriptSrcElem = async ({ algorithm, patterns }) => {
    return await uniqueHashes({
        algorithm,
        parser: scriptTagsContents,
        patterns
    });
};
/**
 * @internal
 */
export const hashesStyleSrcAttr = async ({ algorithm, patterns }) => {
    return await uniqueHashes({
        algorithm,
        parser: inlineStyleContents,
        patterns
    });
};
/**
 * @internal
 */
export const hashesStyleSrcElem = async ({ algorithm, patterns }) => {
    return await uniqueHashes({
        algorithm,
        parser: styleTagsContents,
        patterns
    });
};
/**
 * @internal
 */
export const noHashSpecifiedMessage = (directive) => `CSP directive ${directive}: no hash algorithm specified. No hash will be generated. Return original CSP source values.`;
//# sourceMappingURL=hash.js.map